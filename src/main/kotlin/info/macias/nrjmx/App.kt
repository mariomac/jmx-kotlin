/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package info.macias.nrjmx

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory
import info.macias.kaconf.ConfiguratorBuilder
import info.macias.kaconf.Property
import info.macias.nrjmx.cfg.Collection
import info.macias.nrjmx.connect.AsyncFetcher
import info.macias.nrjmx.connect.JMXConnectionFactory
import info.macias.nrjmx.connect.JMXQuery
import info.macias.nrjmx.connect.JMXResult
import info.macias.nrjmx.emit.IdAttribute
import info.macias.nrjmx.emit.StdoutJSONEmitter
import kotlinx.coroutines.*
import kotlinx.coroutines.channels.Channel
import org.slf4j.LoggerFactory
import java.io.File
import java.util.HashMap
import kotlin.system.exitProcess

class InputConfig {
    @Property("JMX_HOST")
    var host : String = "localhost"

    @Property("JMX_PORT")
    var port : Int = 7199

    @Property("JMX_URL")
    var url: String = "service:jmx:rmi:///jndi/rmi://%s:%s/jmxrmi"

    @Property("COLLECT_FILES")
    var collectFile: String = "tomcat.yaml"

    var timeoutSeconds: Long = 15
}

private val log = LoggerFactory.getLogger("info.macias.nrjmx")

fun main() = runBlocking {
    // Load config
    val config = InputConfig()
    ConfiguratorBuilder()
            .addSource(System.getenv()).build()
            .configure(config)

    // Load collect file
    val collectFile = ObjectMapper(YAMLFactory()).findAndRegisterModules()
            .readValue(File(config.collectFile), Collection::class.java)

    if (collectFile.collect == null) {
        log.error("empty collect file")
        exitProcess(-1)
    }

    // Connect to JMX
    val conn = JMXConnectionFactory(
            String.format(config.url, config.host, config.port))

    val fetcher = AsyncFetcher(conn)

    log.debug("starting fetching")

    val emissionChannel = Channel<JMXResult>()

    // Collect beans and attributes and asynchronously processes them to send them to the
    // emitter channel
    // TODO: use kotlin flows as a potentially cleaner implementation
    val queryJob = async {
        collectFile.collect!! // todo: log exceptions
                .filter { it.domain != null && it.beans != null && it.eventType != null } // todo: log message
                // for each domain
                .map { dom -> async { dom.beans!!
                            .map { bean -> JMXQuery(
                                    domain=dom.domain!!,
                                    eventType = dom.eventType!!,
                                    query = bean.query!!,
                                    host = config.host,
                                    attributes = bean.attributesMap()) }
                            .map { async { fetcher.query(it) } }
                            .awaitAll().flatten()
                            .map { emissionChannel.send(it.await()) } //
                }}.awaitAll()
    }
    queryJob.invokeOnCompletion { emissionChannel.close() }

    // implement timeout
    val timeout = launch {
        delay(config.timeoutSeconds * 1000)
        log.warn("queries did not complete after {} seconds." +
                " Canceling and sending only the received data", config.timeoutSeconds)
        queryJob.cancel("timeout")
        emissionChannel.close()
    }

    log.debug("starting collection")

    StdoutJSONEmitter(emissionChannel, listOf(
            IdAttribute("host", config.host),
            IdAttribute("port", config.port.toString())))

    timeout.cancel("task finished. No timeout")
}

